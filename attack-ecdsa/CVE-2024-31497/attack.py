from pwn import *
from sage.all import * 
from ecdsa.ecdsa import curve_521, generator_521, Public_key, Private_key
from ecdsa.ellipticcurve import Point 
from Crypto.Util.number import bytes_to_long, long_to_bytes, getPrime, inverse
from hashlib import sha512
import random
import json


def get_key(signatures, public_key,bias,q):
    def get_matrix(signatures, bias, q):
        # https://github.com/elikaski/ECC_Attacks?tab=readme-ov-file#generating-k-values-insecurely    
        r1 = [bias, 0]
        r2 = [0, bias / q]
        for m, r, s in signatures:
            r1.append((inverse(s, q) * m) % q)
            r2.append((inverse(s, q) * r) % q)
        
        top_rows = Matrix(QQ, [r1, r2])

        zero_cols = zero_matrix(QQ, len(signatures), 2)
        qI = q * identity_matrix(QQ, len(signatures))
        bottom_rows = block_matrix([[zero_cols, qI]])

        M = top_rows.stack(bottom_rows)
        return M
    M = get_matrix(signatures, bias, q)
    L = M.LLL()
    generator = public_key.generator
    q = generator.order()
    for row in L.rows():
        for i in range(len(signatures)):
            m,r,s = signatures[i]
            possible_k = row[i+2]
            for k in [possible_k, -possible_k]:
                d = inverse_mod(r,q)*(k*s-m) % q
                if d*generator == public_key.point:
                    return d


curve = curve_521
generator = generator_521
q = int(generator_521.order())

conn = remote('localhost', 1337,level = 'debug')


def get_banner():
    print(conn.recvuntil('>').decode())

def get_list_of_signatures():
    signatures = []
    for i in range(60):
        get_banner()
        conn.sendline('2')
        resp = conn.recvline().decode().strip()
        data = json.loads(resp)
        m_hex = data['msg_hex'].encode()
        m_int = data['msg_hash_int']
        r = data['r']
        s = data['s']
        signatures.append((m_int, r, s))

    return signatures
def get_public_key():
    get_banner()
    conn.sendline('1')
    conn.recvline()
    resp = conn.recv().decode().strip()
    data = json.loads(resp)
    Q_x = data['Q_x']
    Q_y = data['Q_y']
    real_point = Point(curve, Q_x, Q_y) 
    pub_key = Public_key(generator, real_point)
    return pub_key

public_key = get_public_key()
signatures = get_list_of_signatures()

bias = 2**512
found_key = get_key(signatures, public_key,bias,q)
print(f"Found private key: {found_key}")
print(f"Expected private key: ",long_to_bytes(found_key).decode())
